use { error, ip-address-family, ip-socket-address, usize } from common-types
use { input-byte-stream, output-byte-stream } from wasi-io-streams
use { network } from wasi-network
use { socket } from wasi-socket

enum shutdown-type {
	/// Similar to `SHUT_RD` in POSIX.
	receive,

	/// Similar to `SHUT_WR` in POSIX.
	send,

	/// Similar to `SHUT_RDWR` in POSIX.
	both,
}

/// Create a new TCP socket.
/// 
/// Similar to `socket(AF_INET or AF_INET6, SOCK_STREAM, 0 or IPPROTO_TCP)` in POSIX.
/// 
/// References:
/// - https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html
/// - https://man7.org/linux/man-pages/man2/socket.2.html
/// 
create-tcp-socket: func(network: handle network, address-family: ip-address-family) -> expected<handle socket, error>

/// TO DISCUSS
as-input-byte-stream: func(tcp-socket: handle socket) -> handle input-byte-stream

/// TO DISCUSS
as-output-byte-stream: func(tcp-socket: handle socket) -> handle output-byte-stream

/// Bind the socket to a specific IP address and port.
///
/// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
/// network interface(s) to bind to.
/// If the TCP/UDP port is zero, the socket will be bound to a random free port.
/// 
/// When a socket is not explicitly bound, the first invocation to a listen or connect operation will
/// implicitly bind the socket.
/// 
/// Returns an error if the socket is already bound.
/// 
/// References
/// - https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html
/// - https://man7.org/linux/man-pages/man2/bind.2.html
bind: async func(tcp-socket: handle socket, local-address: ip-socket-address) -> expected<unit, error>

/// Get the current bound address.
/// 
/// Returns an error if the socket is not bound.
/// 
/// References
/// - https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html
/// - https://man7.org/linux/man-pages/man2/getsockname.2.html
local-address: func(tcp-socket: handle socket) -> expected<ip-socket-address, error>

///	Connect to a remote endpoint.
/// 
/// Transitions the socket into the Connection state.
/// Fails when the socket is already in the Connection or Listener state.
/// 
///  References
/// - https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html
/// - https://man7.org/linux/man-pages/man2/connect.2.html
connect: async func(tcp-socket: handle socket, remote-address: ip-socket-address) -> expected<unit, error>

/// Start listening for new connections.
/// 
/// Transitions the socket into the Listener state.
/// Fails when the socket is already in the Connection or Listener state.
/// 
///  References
/// - https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html
/// - https://man7.org/linux/man-pages/man2/listen.2.html
listen: async func(tcp-socket: handle socket, backlog-size-hint: option<usize>) -> expected<unit, error>

/// Fails when the socket is not in the Connection state.
/// 
/// Read data from the stream just like `InputByteStream::read`, but don't remove the data from the queue.
peek: async func(tcp-socket: handle socket, iovs: push-buffer<u8>) -> expected<usize, error>

/// Fails when the socket is not in the Connection state.
/// 
/// References
/// - https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html
/// - https://man7.org/linux/man-pages/man2/getpeername.2.html
remote-address: func(tcp-socket: handle socket) -> expected<ip-socket-address, error>

/// Gracefully shut down the connection.
/// 
/// - receive: the socket is not expecting to receive any more data from the peer. All subsequent read/receive
///   operations will return 0, indicating End Of Stream. If there is still data in the receive queue at time of
///   calling `shutdown` or whenever new data arrives afterwards, then (TODO).
/// - send: the socket is not expecting to send any more data to the peer. After all data in the send queue has
///   been sent and acknowledged, a FIN will be sent. All subsequent write/send operations will return an
///   EPIPE error.
/// - both: receive & send
/// 
/// The shutdown function does not close the socket.
/// 
/// Fails when the socket is not in the Connection state.
/// 
/// TODO: Look into how different platforms behave after shutdown(Read) has been called and new data arrives. According to the internet (unverified):
/// - BSD: silently discards the data
/// - Linux: effectively ignores the shutdown call. New data can still be read. If not done will ultimately block the sender.
/// - Windows: sends RST
/// 
/// TODO: Look into how different platforms behave when trying to shut down the same direction multiple times.
/// 
/// References
/// - https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html
/// - https://man7.org/linux/man-pages/man2/shutdown.2.html
shutdown: async func(tcp-socket: handle socket, shutdown-type: shutdown-type) -> expected<unit, error>

/// Unlike POSIX, this function does not returns the remote address.
/// If you want to know this information, invoke `remote-address` on the newly created socket.
/// 
/// Fails when this socket is not in the Listening state.
/// 
/// Returns a new bound socket in the Connection state.
/// 
/// References:
/// - https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html
/// - https://man7.org/linux/man-pages/man2/accept.2.html
accept: async func(tcp-socket: handle socket) -> expected<handle socket, error>
